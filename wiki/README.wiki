=CCN Packet Level Simulator - CCNPL-Sim=
In this document, we briefly present the Content Centric Network Packet Level Simulator (CCNPL-Sim). The simulator has been published under the GNU GPL v2 license and is available for download at http://code.google.com/p/ccnpl-sim/. It includes two main packages cbcbsim and cbnsim, an installation file and some toy examples. CCNPL-Sim is built upon CBCBSim (http://www.inf.usi.ch/carzaniga/cbn/routing/index.html#cbcbsim). In particular, its development started from two
packages of the original simulator namely cbcbsim-1.0.2 and cbnsim-1.1.3 2 . Other packages originally used in CBCBSim such as Simple Simulation Library (ssim), Siena Synthetic Benchmark Generator (ssbg) and Siena Simplifier (ssimp) were not modified and are still maintained by their original authors. The only package that required modifications was the Siena Fast Forwarding (sff) one in order to perform longest prefix match lookup during the forwarding phase. In the installation process sff-1.9.5, ssbg-1.3.5, ssim-1.7.5 and ssimp-1.1.5 packages are downloaded from their original website and a patch for the sff-1.9.5 package is applied. The README is divided in three parts. The first one is devoted to present the workload structure, its generation process and the adaptation of the Content Based Network (CBN) naming scheme to the CCN one. The second one better explains the real functioning of the simulator. The latter one briefly illustrates the simulator outputs.

==Workload generator==
In this section we introduce the workload generator tool that is directly derived by the one used in the original CBCBSim.

===Naming adaptation===
In order to better understand the workload construction, let us first introduce the naming schema used in the simulator. CBCBSim makes use of the naming defined by the CBN architecture. CBN names basically consists in a set of attribute/value pairs constituting the flat content-based address (name). In order to be compliant to the current hierarchical URI-like naming schema adopted by CCN, we use the CBN names with some additional constraints. 
The CBN names are of the type:

_message: [class="warning", severity=1, device-type="hard-drive"]_

_selection predicate: [(class="warning") ∨ (alert-type="software-error" ∧ severity=1)]_

in which a message is composed by a set of attribute-value pairs called onstraints and the selection predicate is composed by a disjunction (filters) of conjunctions (predicate) of constraints i.e. the selection predicate presented before is composed by two filters: [class="warning"] and [alert-type="software-error" ∧ severity=1]. In order to have URI-like addresses, we impose that:
  * each constraint corresponds to an element of the URI address i.e. /constraint1/constrant2/../
  * constraints are listed in alphabetical order to represent a URI-like address i.e. the message A = "provider", B ="video", C = "video.mpg" is converted in /provider/video/video.mpg. Notice that also numbers can be used as constraints’ name.
  * selection predicates (prefixes used in the interest forwarding process) are composed by a single filter.

===Input parameters===
The workload file is composed by a set of commands that we briefly introduce in this section. Here is the list of the accepted commands in the workload with their syntax and an example:

  * *time_unit*: indicates the workload’s time unit i.e. if the time unit is 0.0000010000 all the times in the workload file are indicated in μs.
_Example:_ *time_unit *0.0000010000 ;
 
  * *sim_length*: indicates the length of the simulation expressed using the workload’s time unit. Notice that the simulation length is overridden if a length is specified to the simulator.
_Example:_ *sim_length* 500000000000.0000000000 ;

  * *publish_content*: indicates that the specified node in the topology will be the server for the specified content. Notice that a file can be published in different network nodes.
_Example:_ *publish_content* 0 0.0000000000 100 8000 1 100 0 A = "provider" B = "video.mpg" ;

|| column || syntax || example ||
||1||command || publish_content||
||2||node_id || 0 ||
||3||publication time || 0.0000000000 ||
||4||file size `[`packets`]` || 100 ||
||5||packet size `[`bit`]` || 8000 ||
||6||class_id (popularity class in our settings)|| 1 ||
||7,8||unused fields || 100 0 ||
||9, .., ; ||content name || A = "provider" B = "video.mpg" ;||

  * *download_content:* indicates the beginning of the downloading process of the specified content from a particular node.
_Example:_ *download_content* 2 1000000.0000000000 0 A = "provider" B = "video.mpg" ;

||column||syntax||example||
||1||command||download_content||
||2||node_id||2||
||3||download time||1000000.0000000000||
||4||unused field||0||
||5, .., ;|| content prefix || A = "provider" B = "video.mpg" ;||

  * *set_predicate:* this command has been inherited from the CBCBSim. It constructs the shortest path to deliver interest messages from all the potential requester to the node indicated by the command. The command specifies the prefix that will be used during the interest forwarding phase in order to compute the longest prefix match. Notice that this primitive can also be omitted. In this case, routing tables need to be manually specified while launching the simulation run.
_Example:_ *set_predicate* 0 0.0000000000 0 A = "provider" ;

||column||syntax||example||
||1||command||set_predicate||
||2||node_id||0||
||3||time||0.0000000000||
||4||unused field||0||
||5, .., ;||content prefix||A = "provider" ;||

===Generation process===
The workload generator takes as input different files that indicates servers, clients and the list of available files. In particular:
  * *clients.dist:* indicates the nodes that will request and the file request rate e.g. Poisson of rate λ.
  * *prefix.dist:* indicates which prefix(es) a node will serve.
  * *contents.dist:* indicates the contents that will be available for the download, their permanentlocation, their popularity and their size.

During the workload generation process, time_unit and the sim_length are written at the beginning of the workload file. Then, publish_content commands are generated and written in the workload while reading the contents.dist input file. At this stage, if not otherwise specified to the generator, set_predicate commands are generated through the prefix.dist input file. Finally, using the input information given by contents.dist and clients.dist, the download_content commands
are generated according to the request rate/law (i.e. Poisson(λ), λ = 1) and content popularity specified to the workload generator. In [wl_example] a workload example file is reported.

==Simulation run==
In this section we introduce the simulator structure and briefly describe the implementation of the CCN data structures. The simulator needs some parameters including the topology file, the workload file, etc. that are specified using an option file whose structure is presented in [input].

===Execution Process===
Once the simulation is running, CCNPL-Sim relies on a Driver (similar to the one in CBCBSim) to read workload events and on the ssim package to manage other type of events. The ssim package is basically a Discrete-Event Simulation Library that stores scheduled events in a complete binary min heap so that the next event to be executed is always at the top of the tree. 

http://ccnpl-sim.googlecode.com/svn/wiki/fig/sim_process.png

The figure presents an explicative schema of the CCNPL-Sim execution process. The driver reads and dispatch the events from the workload, loading workload events with the same start time. When it finishes, it schedules the next workload event(s) read process to ssim. Notice that workload events dispatched to simulation processes (nodes), can generate delayed events (e.g. packet transmissions, timeouts, etc.) that are scheduled to ssim. Ssim dispatches events to the driver or to network nodes and the event "list" is empty (or the specified simulation time is passed), the simulation execution terminates.

===Networking functionalities===
To construct our network simulator we first develop networking functionalities such as output queues, that are not implemented in CBCBSim. In particular, we implement First In First Out (FIFO) and Fair Queuing (FQ, implemented using the Deficit Round Robin algorithm, DRR) disciplines.