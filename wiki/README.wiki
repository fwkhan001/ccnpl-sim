=CCN Packet Level Simulator - CCNPL-Sim=
In this document, we briefly present the Content Centric Network Packet Level Simulator (CCNPL-Sim). The simulator has been published under the GNU GPL v2 license and is available for download at http://code.google.com/p/ccnpl-sim/. It includes two main packages cbcbsim and cbnsim, an installation file and some toy examples. CCNPL-Sim is built upon CBCBSim (http://www.inf.usi.ch/carzaniga/cbn/routing/index.html#cbcbsim). In particular, its development started from two
packages of the original simulator namely cbcbsim-1.0.2 and cbnsim-1.1.3 2 . Other packages originally used in CBCBSim such as Simple Simulation Library (ssim), Siena Synthetic Benchmark Generator (ssbg) and Siena Simplifier (ssimp) were not modified and are still maintained by their original authors. The only package that required modifications was the Siena Fast Forwarding (sff) one in order to perform longest prefix match lookup during the forwarding phase. In the installation process sff-1.9.5, ssbg-1.3.5, ssim-1.7.5 and ssimp-1.1.5 packages are downloaded from their original website and a patch for the sff-1.9.5 package is applied. The README is divided in three parts. Section [README#Workload_generator] is devoted to present the workload structure, its generation process and the adaptation of the Content Based Network (CBN) naming scheme to the CCN one. Section [README#Simulation_run] better explains the real functioning of the simulator. Finally Section [README#Simulation_outputs] briefly illustrates the simulator outputs.

==Workload generator==
In this section we introduce the workload generator tool that is directly derived by the one used in the original CBCBSim.

===Naming adaptation===
In order to better understand the workload construction, let us first introduce the naming schema used in the simulator. CBCBSim makes use of the naming defined by the CBN architecture. CBN names basically consists in a set of attribute/value pairs constituting the flat content-based address (name). In order to be compliant to the current hierarchical URI-like naming schema adopted by CCN, we use the CBN names with some additional constraints. 
The CBN names are of the type:

_message: [class="warning", severity=1, device-type="hard-drive"]_

_selection predicate: [(class="warning") ∨ (alert-type="software-error" ∧ severity=1)]_

in which a message is composed by a set of attribute-value pairs called onstraints and the selection predicate is composed by a disjunction (filters) of conjunctions (predicate) of constraints i.e. the selection predicate presented before is composed by two filters: [class="warning"] and [alert-type="software-error" ∧ severity=1]. In order to have URI-like addresses, we impose that:
  * each constraint corresponds to an element of the URI address i.e. /constraint1/constrant2/../
  * constraints are listed in alphabetical order to represent a URI-like address i.e. the message A = "provider", B ="video", C = "video.mpg" is converted in /provider/video/video.mpg. Notice that also numbers can be used as constraints’ name.
  * selection predicates (prefixes used in the interest forwarding process) are composed by a single filter.

===Workload syntax===
The workload file is composed by a set of commands that we briefly introduce in this section. Here is the list of the accepted commands in the workload with their syntax and an example:

  * *time_unit*: indicates the workload’s time unit i.e. if the time unit is 0.0000010000 all the times in the workload file are indicated in μs.
_Example:_ *time_unit *0.0000010000 ;
 
  * *sim_length*: indicates the length of the simulation expressed using the workload’s time unit. Notice that the simulation length is overridden if a length is specified to the simulator.
_Example:_ *sim_length* 500000000000.0000000000 ;

  * *publish_content*: indicates that the specified node in the topology will be the server for the specified content. Notice that a file can be published in different network nodes.
_Example:_ *publish_content* 0 0.0000000000 100 8000 1 100 0 A = "provider" B = "video.mpg" ;

|| column || syntax || example ||
||1||command || publish_content||
||2||node_id || 0 ||
||3||publication time || 0.0000000000 ||
||4||file size `[`packets`]` || 100 ||
||5||packet size `[`bit`]` || 8000 ||
||6||class_id (popularity class in our settings)|| 1 ||
||7,8||unused fields || 100 0 ||
||9, .., ; ||content name || A = "provider" B = "video.mpg" ;||

  * *download_content:* indicates the beginning of the downloading process of the specified content from a particular node.
_Example:_ *download_content* 2 1000000.0000000000 0 A = "provider" B = "video.mpg" ;

||column||syntax||example||
||1||command||download_content||
||2||node_id||2||
||3||download time||1000000.0000000000||
||4||unused field||0||
||5, .., ;|| content prefix || A = "provider" B = "video.mpg" ;||

  * *set_predicate:* this command has been inherited from the CBCBSim. It constructs the shortest path to deliver interest messages from all the potential requester to the node indicated by the command. The command specifies the prefix that will be used during the interest forwarding phase in order to compute the longest prefix match. Notice that this primitive can also be omitted. In this case, routing tables need to be manually specified while launching the simulation run.
_Example:_ *set_predicate* 0 0.0000000000 0 A = "provider" ;

||column||syntax||example||
||1||command||set_predicate||
||2||node_id||0||
||3||time||0.0000000000||
||4||unused field||0||
||5, .., ;||content prefix||A = "provider" ;||

===Generation process===
The workload generator takes as input different files that indicates servers, clients and the list of available files. In particular:
  * *clients.dist:* indicates the nodes that will request and the file request rate e.g. Poisson of rate λ.
  * *prefix.dist:* indicates which prefix(es) a node will serve.
  * *contents.dist:* indicates the contents that will be available for the download, their permanentlocation, their popularity and their size.

During the workload generation process, *time_unit* and the *sim_length* are written at the beginning of the workload file. Then, *publish_content* commands are generated and written in the workload while reading the *contents.dist* input file. At this stage, if not otherwise specified to the generator, *set_predicate* commands are generated through the *prefix.dist* input file. Finally, using the input information given by *contents.dist* and *clients.dist*, the *download_content* commands are generated according to the request rate/law (i.e. Poisson(λ), λ = 1) and content popularity specified to the workload generator. In [wl_example] a workload example file is reported.

==Simulation run==
In this section we introduce the simulator structure and briefly describe the implementation of the CCN data structures. The simulator needs some parameters including the topology file, the workload file, etc. that are specified using an option file whose structure is presented in [input].

===Execution Process===
Once the simulation is running, CCNPL-Sim relies on a Driver (similar to the one in CBCBSim) to read workload events and on the ssim package to manage other type of events. The ssim package is basically a Discrete-Event Simulation Library that stores scheduled events in a complete binary min heap so that the next event to be executed is always at the top of the tree. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/sim_process.png </P>

The figure presents an explicative schema of the CCNPL-Sim execution process. The driver reads and dispatch the events from the workload, loading workload events with the same start time. When it finishes, it schedules the next workload event(s) read process to ssim. Notice that workload events dispatched to simulation processes (nodes), can generate delayed events (e.g. packet transmissions, timeouts, etc.) that are scheduled to ssim. Ssim dispatches events to the driver or to network nodes and the event "list" is empty (or the specified simulation time is passed), the simulation execution terminates.

===Networking functionalities===
To construct our network simulator we first develop networking functionalities such as output queues, that are not implemented in CBCBSim. In particular, we implement First In First Out (FIFO) and Fair Queuing (FQ, implemented using the Deficit Round Robin algorithm, DRR) disciplines.

===CCN data structures and packet types===
In order the develop a CCN simulator, we need to implement CCN specific data structures such as Pending Interest Table (PIT), Forwarding Information Base (FIB) and Content Store (CS, Cache). Here we are not interested in the PIT,CS,FIB rolesbut in briefly recall their usage and introduce their implementations in CCNPL-Sim. Notice that differently from the CCNx implementation (www.ccnx.org/), we strictly separate the three data structures. Furthermore we briefly present the packet types used in CCNPL-Sim.

====Pending Interest Table - PIT====
The PIT keeps track of forwarded interests in order to guide data packets back to its requestor(s). If there exists another PIT entry for the same content name, the interest is not forwarded and the interface from which it has been received is saved. Notice that in order to be able to enable/disable the so called "filtering" feature, we keep a PIT entry for each received interest (differently to the
CCNx implementation) in our implementation. To have fast insert, search and delete operations in the PIT, we implement it with two data structures. This because the three basic PIT operations need to access the PIT in different ways:
  * insert and search: look-up by content name.
  * delete: remove expired PIT entries accessing elements by insertion time.

For this reasons, we use two mutually linked data structures. A hash table (unordered multimap - boost libraries) for accessing elements by packet name (content name + packet identifier) and an ordered list (map - std C++ libraries) in order to maintain records ordered by insertion time and delete PIT entries consequently. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/PIT.png </P>

The figure illustrates the PIT implementation.


====Content Store - CS====
The Content Store (CS) in CCN is a temporary memory (cache) used by nodes to directly reply to interests if the requested packet is stored locally. Notice that in order to speed up the content repository we distinguish permanent and cached copies. Permanent copies are stored in a list at the content repository that is checked for the first interest only. Cached copies instead are stored in the CS of the network nodes. As for the PIT, we need to have fast access operations in order to speed up the simulation. The LRU and RND replacement policies are slightly different in terms of insert, search and delete requirements:
  * insert and search: both LRU and RND need to look-up the CS by content name.
  * delete: LRU policy needs to remove least recently used packets while RND one pick a packet at random.

Therefore, LRU and RND cache structures are slightly different. The LRU is implemented with two mutually linked data structures. Like the PIT, LRU is constructed with a hash table (unordered map - boost libraries) and an ordered list (list - C++ libraries) respectively for search by name and delete least recently used packet(s). Notice that differently from the PIT, for the CS we used a standard list. This because the element that need to be inserted is always the least recently used and hence it is easy to keep the list ordered by inserting new elements on top of it. The RND replacement policy only needs a hash table to search by name operations as delete decision is taken randomly.

Contrarily from the PIT implementation, the CS hash table maintains a record for each content name (and not content name + packet identifier) in order to maintain few records and use less computationally expensive hash functions. Due to this implementation choice, we need that each packet carries the size (in number of packets) of the content it belongs to (this requirement can be relaxed in the future if the simulator need to manage contents whose size is not known a priori).
Moreover, for the RND implementation we also need an auxiliary list in order to easily perform random packet(s) removal. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/cache.png" </P>

The figure illustrates the LRU and RND implementation.

====Forwarding Information Base - FIB====

In CCN, the Forwarding Information Base is used to guide Interest toward possible destinations. The FIB structure in CCNPL-Sim is implemented starting from the one employed by CBCBSim. The forwarding table in CBCBSim is an extension of the basic matching algorithm known as the counting algorithm and its implementation is described in "Forwarding in a content-based network" by Carzaniga et al. Due to the different naming scheme used in CBCBSim, we modify the original FIB match
function in order to support the longest prefix match operation of CCN nodes. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/fwd_table.png" </P>

The figure illustrates the structure of the forwarding table (the figure is partly copied from “Forwarding in a content-based network,”by  Carzaniga, A. and Wolf, A. L.,in Proc. of ACM SIGCOMM, 2003).

====Packet types====
In CCNPL-Sim we define packets as events that move from a node (alos referred to as process) to another. Obviously like in CCN there are two different packet types: Interests and Data packets.
  * *interest:* contains the message packet used in the original CBCBSim that is matched against the forwarding table during the interest forwarding process. Furthermore, we add URI-like content name, packet identifier, content size (in packets) and other auxiliary information. If the packet identifier is 0, the interest is sent to acquire informations on the content that is requested i.e. number of packets, packet size, etc. Interest packet size is set to 25 Bytes as default.
  * *data:* contains the informations also carried by the interest packet except from the message packet. If the packet identifier is 0, the data packet (also INFO packet) is sent to reply to an interest packet with packet id 0. Data packet size can vary and is defined by the *publish_content* command in the workload file (see [README#Input_parameters]).

==Simulation outputs==
The simulator produces two different output files. The first one is directly printed in *stdout* and records runtime events e.g. the termination of a content download process. Notice that in principle each event handled by the simulator (packet received, packet sent, packet lost, etc.) can be printed to *stdout*. However print operations significantly increment the simulation execution time and
the *stdout* statistics collected by the released version of the simulator are limited to events that represent the end of a content download process. The syntax of the *stdout* output file is represented in the following table:

||column||syntax||example||
||1||simulation time || 3169053.0000000000 ||
||2,3||event || closed socket ||
||4||node id || 2 ||
||5|| content_name+port_id || /Orange/wgpfowikcv/port:0  ||
||6|| delivery time `[`sec`]` || 1.023  ||
||7|| file size `[`bits`]` || 80000  ||
||8|| average RTT `[`sec`]` || 0.0010  ||
||9|| average packaet delay (take into account retransmissions) `[`sec`]` || 0.0015  ||
||10|| keyword || class  ||
||11|| popularity class || 2  ||
||12|| sockets still opened in this node || 10  ||
||13|| avg receiver interest window size || 5.4 ||
||14|| number of exploited routes || 5  ||
||15|| average number of exploited routes || 2.4  ||

The second output file is a log saved to the path/file name specified to the simulator through the *outputfile* input parameter. The statistics collected in this file are of three different types. The first one represents network performance as the average queue occupancy) and is preceded by the *QUEUE stats:* keyword. The following table present an example QUEUE satistics:

||column||syntax||example||
||1||keyword || QUEUE `[`FINAL`]`||
||2||time (only if not final queue statistic)|| 1.0 ||
||3||keyword || NODE||
||4|| node id || 1 ||
||5|| keyword || to  ||
||6|| node id || 2  ||
||7|| average queue size [packets] || 10.43  ||

The second set of statistics collected in the *outputfile* represents per pupularity class cache performance (miss, hit, inpu/output request rate) and is preceeded by the Stats: keyword. The following table present an example CACHE satistics: 

||column||syntax||example||
||1||keyword || CACHE `[`FINAL`]` NODE ||
||2||time (only if not final queue statistic) `[`sec`]`|| 2.0 ||
||3||node id || 1 ||
||4||request miss rate || 2 ||
||5||request hit rate || 0.988 ||
||6||request rate|| 2.988  ||
||7|| miss probability (with filtered requests as miss)|| 0.6711  ||
||8|| hit probability || 0.3289  ||
||9|| request filter probability || 0  ||
||10|| miss probability (without filtered requests)|| 0.6711 ||
||11|| keyword || class ||
||12|| calass_id (popularity class in our settings)|| 1 ||

The third and last set of statistic represents per node and per forwarding prefix split ratio/rate in case of multipath scenario. An example of the split statistic is represented in the following table: 

||column||syntax||example||
||1||keyword || SPLIT `[`FINAL`]` NODE||
||2||time (only if not final queue statistic) `[`sec`]`|| 2.0 ||
||3||keyword || NODE||
||4|| node id || 1 ||
||5|| keyword || to  ||
||6|| node id || 2  ||
||7|| forwarded requests `[`\%`]` || 23.3  ||
||8|| forwarded requests `[`rate`]` || 1.4  ||

Notice that the three groups of statistics are printed out each t,,i,, seconds as specified by the parameter *dci* (data collection interval) and at the end of the simulation (if t,,i,, = 0 only final statistics are collected).