=CCN Packet Level Simulator - CCNPL-Sim=

In this document, we briefly present the Content Centric Network Packet Level Simulator (CCNPL-Sim). The simulator has been published under the GNU GPL v2 license and is available for download at http://code.google.com/p/ccnpl-sim/. It includes two main packages cbcbsim and cbnsim, an installation file and some toy examples. CCNPL-Sim is built upon CBCBSim (http://www.inf.usi.ch/carzaniga/cbn/routing/index.html#cbcbsim). In particular, its development started from two
packages of the original simulator namely cbcbsim-1.0.2 and cbnsim-1.1.3 2 . Other packages originally used in CBCBSim such as Simple Simulation Library (ssim), Siena Synthetic Benchmark Generator (ssbg) and Siena Simplifier (ssimp) were not modified and are still maintained by their original authors. The only package that required modifications was the Siena Fast Forwarding (sff) one in order to perform longest prefix match lookup during the forwarding phase. In the installation process sff-1.9.5, ssbg-1.3.5, ssim-1.7.5 and ssimp-1.1.5 packages are downloaded from their original website and a patch for the sff-1.9.5 package is applied. The README is divided in three parts. Section [README#Workload_generator] is devoted to present the workload structure, its generation process and the adaptation of the Content Based Network (CBN) naming scheme to the CCN one. Section [README#Simulation_run] better explains the real functioning of the simulator. Finally Section [README#Simulation_outputs] briefly illustrates the simulator outputs.

==Workload generator==
In this section we introduce the workload generator tool that is directly derived by the one used in the original CBCBSim.

[Naming]

[Workload_Syntax]

===Generation process===
The workload generator takes as input different files that indicates servers, clients and the list of available files. In particular:
  * *clients.dist:* indicates the nodes that will request and the file request rate e.g. Poisson of rate λ. Example file @ http://code.google.com/p/ccnpl-sim/source/browse/tags/examples/caching_single_LRU/clients.dist
Example: 2 poisson 1

||column||syntax||example||
||1||node`_`id || 2 ||
||2||request distribution || poisson ||
||3|| rate || 1 ||

  * *prefix.dist:* indicates which prefix(es) a node will serve.Example file @ 
http://code.google.com/p/ccnpl-sim/source/browse/tags/examples/caching_single_LRU/prefix.dist
Example: 0 A = "Orange"

||column||syntax||example||
||1||node`_`id || 0 ||
||2, .., ;||content prefix || A = "provider" ;||

  * *contents.dist:* indicates the contents that will be available for the download, their permanent location, their popularity and their size. Example file @
http://code.google.com/p/ccnpl-sim/source/browse/tags/examples/caching_single_LRU/final_names20000_constsize.dist

Example: 0.4871169634416396 0.5 1 80000 0 0 100 0 A = "Orange" B = "dsaphonwmf" ;

||column||syntax||example||
||1||class request cumulative probability (multiple entries with the same cum. prob. belongs to the same class) || 0.4871169634416396 ||
||2||file request cumulative probability (cum. probability of requesting a file in the given class) || 0.5 ||
||3||file size `[`packets`]` || 1 ||
||4||chunk size `[`bit]|| 80000 ||
||5||node`_`id|| 0 ||
||6,7,8||unused||  ||
||9, .., ;||content name || A = "Orange" B = "dsaphonwmf" ;||

During the workload generation process, _time`_`unit_ and the _sim`_`length_ are written at the beginning of the workload file. Then, _publish`_`content_ commands are generated and written in the workload while reading the *contents.dist* input file. At this stage, if not otherwise specified to the generator, *set_predicate* commands are generated through the *prefix.dist* input file. Finally, using the input information given by *contents.dist* and *clients.dist*, the _download`_`content_ commands are generated according to the request rate/law (i.e. Poisson(λ), λ = 1) and content popularity specified to the workload generator. This is an example of the command used in order to automatically generate a workload file:

{{{
../../ccnpl-sim/cbnsim/bin/cbnwlgen -l 500e+03 -wtu 1e-06 -man_routing -files files.dist -prefix prefix.dist -clients clients.dist 
}}}

options of the workload generation command are: 
  * -l sim length `[`sec`]`;
  * -wtu time unit `[`sec`]`;
  * -man_routing if present omit the automatic routing (from CBN simulator);
  * -files specify the files published in the network, their probability, etc.;
  * -prefix specify the prefixes at the servers (not needed if manual routing);
  * -clients specify the clients, their request rate, etc.

In [wl_example] a workload example file is reported.

==Simulation run==
In this section we introduce the simulator structure and briefly describe the implementation of the CCN data structures. The simulator needs some parameters including the topology file, the workload file, etc. that are specified using an option file whose structure is presented in [input]. 
This is an example of the command used to launch the simulation:

{{{
../../ccnpl-sim/bin/cbcbsim -input option_file > stderr.log
}}}

with the option file used in the caching_single_LRU example http://code.google.com/p/ccnpl-sim/source/browse/tags/examples/caching_single_LRU/option_file
The option file specify three input files. The first one is the workload file that we described before. The other two are respectively the topology and the routing file that we briefly explain hereafter.
  * *topo.brite*: used to describe the topology to the simulator. The file is divided in two parts (nodes and edges) that we describe in the next two tables.
Nodes:
||column||syntax||example||
||1||node_id|| 0 ||
||2||x coordinate || 10 ||
||3||y coordinate || 1 ||
||4||cache size `[`kbit`]`|| 160000 ||
||5||cache replacement policy|| 0 ||
||6,7||unused||  ||

Links:
||column||syntax||example||
||1||link_id|| 0 ||
||2||from || 0 ||
||3||to || 1 ||
||4||queue size `[`kbit`]`|| 100000.0 ||
||5||link delay `[`s`]` || 0.001 ||
||6||link capacity `[`kbps`]`|| 100000.0 ||
||7,8||unused|| ||

Example @ http://code.google.com/p/ccnpl-sim/source/browse/tags/examples/caching_single_LRU/topo.brite

* *roting.dist*: used to manually specify the routing tables. Automatic routing is written in the workload and can be omitted using the -man_routing option during the workload generation process.
Example: 0 0 A = "Orange" ;

||column||syntax||example||
||1||node`_`id (from)|| 0 ||
||2||node`_`id (to)|| 1 ||
||3, .., ;||content prefix || A = "provider" ;||

Notice that if from and to node_id coincide this means that the node serves the specified prefix (if this is not present, the node will not reply to interests).
Example @ http://code.google.com/p/ccnpl-sim/source/browse/tags/examples/caching_single_LRU/option_file/routing.dist

===Execution Process===
Once the simulation is running, CCNPL-Sim relies on a Driver (similar to the one in CBCBSim) to read workload events and on the ssim package to manage other type of events. The ssim package is basically a Discrete-Event Simulation Library that stores scheduled events in a complete binary min heap so that the next event to be executed is always at the top of the tree. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/sim_process.png </P>

The figure presents an explicative schema of the CCNPL-Sim execution process. The driver reads and dispatch the events from the workload, loading workload events with the same start time. When it finishes, it schedules the next workload event(s) read process to ssim. Notice that workload events dispatched to simulation processes (nodes), can generate delayed events (e.g. packet transmissions, timeouts, etc.) that are scheduled to ssim. Ssim dispatches events to the driver or to network nodes and the event "list" is empty (or the specified simulation time is passed), the simulation execution terminates.

===Networking functionalities===
To construct our network simulator we first develop networking functionalities such as output queues, that are not implemented in CBCBSim. In particular, we implement First In First Out (FIFO) and Fair Queuing (FQ, implemented using the Deficit Round Robin algorithm, DRR) disciplines.

===CCN data structures and packet types===
In order the develop a CCN simulator, we need to implement CCN specific data structures such as Pending Interest Table (PIT), Forwarding Information Base (FIB) and Content Store (CS, Cache). Here we are not interested in the PIT,CS,FIB rolesbut in briefly recall their usage and introduce their implementations in CCNPL-Sim. Notice that differently from the CCNx implementation (www.ccnx.org/), we strictly separate the three data structures. Furthermore we briefly present the packet types used in CCNPL-Sim.

====Pending Interest Table - PIT====
The PIT keeps track of forwarded interests in order to guide data packets back to its requestor(s). If there exists another PIT entry for the same content name, the interest is not forwarded and the interface from which it has been received is saved. Notice that in order to be able to enable/disable the so called "filtering" feature, we keep a PIT entry for each received interest (differently to the
CCNx implementation) in our implementation. To have fast insert, search and delete operations in the PIT, we implement it with two data structures. This because the three basic PIT operations need to access the PIT in different ways:
  * insert and search: look-up by content name.
  * delete: remove expired PIT entries accessing elements by insertion time.

For this reasons, we use two mutually linked data structures. A hash table (unordered multimap - boost libraries) for accessing elements by packet name (content name + packet identifier) and an ordered list (map - std C++ libraries) in order to maintain records ordered by insertion time and delete PIT entries consequently. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/PIT.png </P>

The figure illustrates the PIT implementation.


====Content Store - CS====
The Content Store (CS) in CCN is a temporary memory (cache) used by nodes to directly reply to interests if the requested packet is stored locally. Notice that in order to speed up the content repository we distinguish permanent and cached copies. Permanent copies are stored in a list at the content repository that is checked for the first interest only. Cached copies instead are stored in the CS of the network nodes. As for the PIT, we need to have fast access operations in order to speed up the simulation. The LRU and RND replacement policies are slightly different in terms of insert, search and delete requirements:
  * insert and search: both LRU and RND need to look-up the CS by content name.
  * delete: LRU policy needs to remove least recently used packets while RND one pick a packet at random.

Therefore, LRU and RND cache structures are slightly different. The LRU is implemented with two mutually linked data structures. Like the PIT, LRU is constructed with a hash table (unordered map - boost libraries) and an ordered list (list - C++ libraries) respectively for search by name and delete least recently used packet(s). Notice that differently from the PIT, for the CS we used a standard list. This because the element that need to be inserted is always the least recently used and hence it is easy to keep the list ordered by inserting new elements on top of it. The RND replacement policy only needs a hash table to search by name operations as delete decision is taken randomly.

Contrarily from the PIT implementation, the CS hash table maintains a record for each content name (and not content name + packet identifier) in order to maintain few records and use less computationally expensive hash functions. Due to this implementation choice, we need that each packet carries the size (in number of packets) of the content it belongs to (this requirement can be relaxed in the future if the simulator need to manage contents whose size is not known a priori).
Moreover, for the RND implementation we also need an auxiliary list in order to easily perform random packet(s) removal. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/cache.png" </P>

The figure illustrates the LRU and RND implementation.

====Forwarding Information Base - FIB====

In CCN, the Forwarding Information Base is used to guide Interest toward possible destinations. The FIB structure in CCNPL-Sim is implemented starting from the one employed by CBCBSim. The forwarding table in CBCBSim is an extension of the basic matching algorithm known as the counting algorithm and its implementation is described in "Forwarding in a content-based network" by Carzaniga et al. Due to the different naming scheme used in CBCBSim, we modify the original FIB match
function in order to support the longest prefix match operation of CCN nodes. 

<P align="center"> http://ccnpl-sim.googlecode.com/svn/wiki/fig/fwd_table.png" </P>

The figure illustrates the structure of the forwarding table (the figure is partly copied from “Forwarding in a content-based network,”by  Carzaniga, A. and Wolf, A. L.,in Proc. of ACM SIGCOMM, 2003).

====Packet types====
In CCNPL-Sim we define packets as events that move from a node (alos referred to as process) to another. Obviously like in CCN there are two different packet types: Interests and Data packets.
  * *interest:* contains the message packet used in the original CBCBSim that is matched against the forwarding table during the interest forwarding process. Furthermore, we add URI-like content name, packet identifier, content size (in packets) and other auxiliary information. If the packet identifier is 0, the interest is sent to acquire informations on the content that is requested i.e. number of packets, packet size, etc. Interest packet size is set to 25 Bytes as default.
  * *data:* contains the informations also carried by the interest packet except from the message packet. If the packet identifier is 0, the data packet (also INFO packet) is sent to reply to an interest packet with packet id 0. Data packet size can vary and is defined by the *publish_content* command in the workload file (see [README#Input_parameters]).

==Simulation outputs==
The simulator produces two different output files. The first one is directly printed in *stdout* and records runtime events e.g. the termination of a content download process. Notice that in principle each event handled by the simulator (packet received, packet sent, packet lost, etc.) can be printed to *stdout*. However print operations significantly increment the simulation execution time and
the *stdout* statistics collected by the released version of the simulator are limited to events that represent the end of a content download process. The syntax of the *stdout* output file is represented in the following table:

||column||syntax||example||
||1||simulation time || 3169053.0000000000 ||
||2,3||event || closed socket ||
||4||node id || 2 ||
||5|| content_name+port_id || /Orange/wgpfowikcv/port:0  ||
||6|| delivery time `[`sec`]` || 1.023  ||
||7|| file size `[`bits`]` || 80000  ||
||8|| average RTT `[`sec`]` || 0.0010  ||
||9|| average packaet delay (take into account retransmissions) `[`sec`]` || 0.0015  ||
||10|| keyword || class  ||
||11|| popularity class || 2  ||
||12|| sockets still opened in this node || 10  ||
||13|| avg receiver interest window size || 5.4 ||
||14|| number of exploited routes || 5  ||
||15|| average number of exploited routes || 2.4  ||

The second output file is a log saved to the path/file name specified to the simulator through the *outputfile* input parameter. The statistics collected in this file are of three different types. The first one represents network performance as the average queue occupancy) and is preceded by the *QUEUE stats:* keyword. The following table present an example QUEUE satistics:

||column||syntax||example||
||1||keyword || QUEUE `[`FINAL`]`||
||2||time (only if not final queue statistic)|| 1.0 ||
||3||keyword || NODE||
||4|| node id || 1 ||
||5|| keyword || to  ||
||6|| node id || 2  ||
||7|| average queue size [packets] || 10.43  ||

The second set of statistics collected in the *outputfile* represents per pupularity class cache performance (miss, hit, inpu/output request rate) and is preceeded by the Stats: keyword. The following table present an example CACHE satistics: 

||column||syntax||example||
||1||keyword || CACHE `[`FINAL`]` NODE ||
||2||time (only if not final queue statistic) `[`sec`]`|| 2.0 ||
||3||node id || 1 ||
||4||request miss rate || 2 ||
||5||request hit rate || 0.988 ||
||6||request rate|| 2.988  ||
||7|| miss probability (with filtered requests as miss)|| 0.6711  ||
||8|| hit probability || 0.3289  ||
||9|| request filter probability || 0  ||
||10|| miss probability (without filtered requests)|| 0.6711 ||
||11|| keyword || class ||
||12|| calass_id (popularity class in our settings)|| 1 ||

The third and last set of statistic represents per node and per forwarding prefix split ratio/rate in case of multipath scenario. An example of the split statistic is represented in the following table: 

||column||syntax||example||
||1||keyword || SPLIT `[`FINAL`]` NODE||
||2||time (only if not final queue statistic) `[`sec`]`|| 2.0 ||
||3||keyword || NODE||
||4|| node id || 1 ||
||5|| keyword || to  ||
||6|| node id || 2  ||
||7|| forwarded requests `[`\%`]` || 23.3  ||
||8|| forwarded requests `[`rate`]` || 1.4  ||

Notice that the three groups of statistics are printed out each t,,i,, seconds as specified by the parameter *dci* (data collection interval) and at the end of the simulation (if t,,i,, = 0 only final statistics are collected).